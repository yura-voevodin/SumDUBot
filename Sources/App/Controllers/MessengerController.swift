//
//  MessengerController.swift
//  SumDUBot
//
//  Created by Yura Voevodin on 18.09.17.
//
//

import HTTP
import Vapor
import Foundation

final class MessengerController {
    
    // MARK: - Properties
    
    let client: ClientFactoryProtocol
    let secret: String
    let token: String
    
    // MARK: - Initialization
    
    init(drop: Droplet) throws {
        // Client
        self.client = try drop.config.resolveClient()
        
        // Read Facebook Messenger secret key from Config/secrets/app.json.
        secret = drop.config["app", "messenger", "secret"]?.string ?? ""
        token = drop.config["app", "messenger", "token"]?.string ?? ""
        
        guard secret != "" && token != "" else {
            // Show errors in console.
            drop.console.error("Missing secret or token keys!")
            drop.console.error("Add almost one in Config/secrets/app.json")
            
            // Throw missing secret key error.
            throw MessengerBotError.missingAppSecrets
        }
        
        // Add routes
        
        // Setting up the GET request with Facebook Messenger secret key.
        // With a secret path to be sure that nobody else knows that URL.
        // This is the Step 2 of Facebook Messenger Quick Start guide:
        // https://developers.facebook.com/docs/messenger-platform/guides/quick-start#setup_webhook
        drop.get("webhook", handler: getWebhook)
        
        // Setting up the POST request with Messenger secret key.
        // With a secret path to be sure that nobody else knows that URL.
        // This is the Step 5 of Facebook Messenger Quick Start guide:
        // https://developers.facebook.com/docs/messenger-platform/guides/quick-start#receive_messages
        drop.post("webhook", handler: postWebhook)
    }
    
    func getWebhook(request: Request) throws -> ResponseRepresentable {
        let object = request.query?.object
        
        /// Check for "hub.mode", "hub.verify_token" & "hub.challenge" query parameters.
        guard object?["hub.mode"]?.string == "subscribe" && object?["hub.verify_token"]?.string == secret, let challenge = object?["hub.challenge"]?.string else {
            throw Abort(.badRequest, reason: "Missing Messenger verification data.")
        }
        
        /// Create a response with the challenge query parameter to verify the webhook.
        return Response(status: .ok, headers: ["Content-Type": "text/plain"], body: challenge)
    }
    
    func postWebhook(request: Request) throws -> ResponseRepresentable {
        /// Check that the request comes from a "page".
        guard request.json?["object"]?.string == "page" else {
            /// Throw an abort response, with a custom message.
            let reason = "Message not generated by a page."
            print(reason)
            throw Abort(.badRequest, reason: reason)
        }
        let emptyResponseText = "üôÅ –ó–∞ –≤–∞—à–∏–º –∑–∞–ø–∏—Ç–æ–º –Ω—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —Å–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–∏–π"
        
        /// Entries from request JSON.
        let entries: [JSON] = request.json?["entry"]?.array ?? []
        
        /// Iterate over all entries.
        for entry in entries {
            /// Page ID of the entry.
            let _: String = entry.object?["id"]?.string ?? "0"
            /// Messages from entry.
            let messaging: [JSON] = entry.object?["messaging"]?.array ?? []
            
            /// Iterate over all messaging objects.
            for event in messaging {
                /// Message of the event.
                let message: [String: JSON] = event.object?["message"]?.object ?? [:]
                /// Postback of the event.
                let postback: [String: JSON] = event.object?["postback"]?.object ?? [:]
                /// Sender of the event.
                let sender: [String: JSON] = event.object?["sender"]?.object ?? [:]
                /// Sender ID, it is used to make a response to the right user.
                let senderID: String = sender["id"]?.string ?? ""
                /// Text sent to bot.
                let text: String = message["text"]?.string ?? ""
                
                /// Check if is a postback action.
                if !postback.isEmpty {
                    /// Get payload from postback.
                    let payload: String = postback["payload"]?.string ?? "No payload provided by developer."

                    if payload.hasPrefix(ObjectType.auditorium.prefix) {
                        // Auditorium
                        let result = try Auditorium.show(for: payload, client: client)
                        if result.isEmpty {
                            try sendResponse(response: Messenger.message(emptyResponseText), senderID: senderID)
                        } else {
                            for item in result {
                                try sendResponse(response: Messenger.message(item), senderID: senderID)
                            }
                            return try ok()
                        }
                    } else if payload.hasPrefix(ObjectType.group.prefix) {
                        // Group
                        let result = try Group.show(for: payload, client: client)
                        if result.isEmpty {
                            try sendResponse(response: Messenger.message(emptyResponseText), senderID: senderID)
                        } else {
                            for item in result {
                                try sendResponse(response: Messenger.message(item), senderID: senderID)
                            }
                            return try ok()
                        }
                    } else if payload.hasPrefix(ObjectType.teacher.prefix) {
                        // Teacher
                        let result = try Teacher.show(for: payload, client: client)
                        if result.isEmpty {
                            try sendResponse(response: Messenger.message(emptyResponseText), senderID: senderID)
                        } else {
                            for item in result {
                                try sendResponse(response: Messenger.message(item), senderID: senderID)
                            }
                            return try ok()
                        }
                    }
                    /// Check if the message object is empty.
                } else if message.isEmpty {
                    /// Set the response message text.
                    let message = Messenger.message("Webhook received unknown event.")
                    try self.sendResponse(response: message, senderID: senderID)
                    /// Check if the message text is empty
                } else if text.isEmpty {
                    /// Set the response message text.
                    let message = Messenger.message("–í–∞—Å –≤—ñ—Ç–∞—î –±–æ—Ç —Ä–æ–∑–∫–ª–∞–¥—É –°—É–º–î–£! üôã‚Äç‚ôÇÔ∏è")
                    try self.sendResponse(response: message, senderID: senderID)
                } else {
                    // Search
                    if text.count <= 3 {
                        let message = Messenger.message("–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–∏–º–≤–æ–ª—ñ–≤ –¥–ª—è –ø–æ—à—É–∫—É —Ä—ñ–≤–Ω–∞ 4")
                        try self.sendResponse(response: message, senderID: senderID)
                    } else {
                        // Auditoriums
                        var auditoriums: [Button] = []
                        auditoriums = try Auditorium.find(by: text)
                        if !auditoriums.isEmpty {
                            let groupedButtons = Button.groupForResponse(auditoriums)
                            for buttons in groupedButtons {
                                let message = try Messenger.buttons(buttons, title: "–ê—É–¥–∏—Ç–æ—Ä—ñ—ó")
                                try self.sendResponse(response: message, senderID: senderID)
                            }
                        }
                        
                        // Groups
                        var groups: [Button] = []
                        groups = try Group.find(by: text)
                        if !groups.isEmpty {
                            let groupedButtons = Button.groupForResponse(groups)
                            for buttons in groupedButtons {
                                let message = try Messenger.buttons(buttons, title: "–ì—Ä—É–ø–∏")
                                try self.sendResponse(response: message, senderID: senderID)
                            }
                        }
                        // Teachers
                        var teachers: [Button] = []
                        teachers = try Teacher.find(by: text)
                        if !teachers.isEmpty {
                            let groupedButtons = Button.groupForResponse(teachers)
                            for buttons in groupedButtons {
                                let message = try Messenger.buttons(buttons, title: "–í–∏–∫–ª–∞–¥–∞—á—ñ")
                                try self.sendResponse(response: message, senderID: senderID)
                            }
                        }
                        if auditoriums.isEmpty && groups.isEmpty && teachers.isEmpty {
                            let message = Messenger.message(emptyResponseText)
                            try self.sendResponse(response: message, senderID: senderID)
                        }
                    }
                }
            }
        }
        return try ok()
    }
    
    fileprivate func sendResponse(response: Node, senderID: String) throws {
        /// Creating the response JSON data bytes.
        /// At Step 6 of Facebook Messenger Quick Start guide, using Node.js demo, they told you to send back the "recipient.id", but the correct one is "sender.id".
        /// https://developers.facebook.com/docs/messenger-platform/guides/quick-start#send_text_message
        var responseData: JSON = JSON()
        try responseData.set("recipient", ["id": senderID])
        try responseData.set("message", response)
        
        /// Calling the Facebook API to send the response.
        let response: Response = try self.client.post("https://graph.facebook.com/v2.9/me/messages", query: ["access_token": token], ["Content-Type": "application/json"], Body.data(responseData.makeBytes()))
        print(response.description)
        print(response.headers)
        print(response.status)
    }
    
    fileprivate func ok() throws -> ResponseRepresentable {
        /// Sending an HTTP 200 OK response is required.
        /// https://developers.facebook.com/docs/messenger-platform/webhook-reference#response
        /// The header is added just to mute a Vapor warning.
        return Response(status: .ok, headers: ["Content-Type": "application/json"])
    }
}
